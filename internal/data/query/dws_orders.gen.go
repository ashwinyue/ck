// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"ck/internal/data/model"
)

func newDwsOrder(db *gorm.DB, opts ...gen.DOOption) dwsOrder {
	_dwsOrder := dwsOrder{}

	_dwsOrder.dwsOrderDo.UseDB(db, opts...)
	_dwsOrder.dwsOrderDo.UseModel(&model.DwsOrder{})

	tableName := _dwsOrder.dwsOrderDo.TableName()
	_dwsOrder.ALL = field.NewAsterisk(tableName)
	_dwsOrder.ID = field.NewInt64(tableName, "id")
	_dwsOrder.OrderID = field.NewString(tableName, "order_id")
	_dwsOrder.CustomerID = field.NewInt64(tableName, "customer_id")
	_dwsOrder.OrderAmount = field.NewFloat64(tableName, "order_amount")
	_dwsOrder.OrderStatus = field.NewString(tableName, "order_status")
	_dwsOrder.OrderDate = field.NewTime(tableName, "order_date")
	_dwsOrder.PaymentMethod = field.NewString(tableName, "payment_method")
	_dwsOrder.ShippingAddress = field.NewString(tableName, "shipping_address")
	_dwsOrder.PushStatus = field.NewString(tableName, "push_status")
	_dwsOrder.CreatedAt = field.NewTime(tableName, "created_at")
	_dwsOrder.UpdatedAt = field.NewTime(tableName, "updated_at")

	_dwsOrder.fillFieldMap()

	return _dwsOrder
}

// dwsOrder DWS Orders Table - Data Warehouse Service Layer
type dwsOrder struct {
	dwsOrderDo

	ALL             field.Asterisk
	ID              field.Int64
	OrderID         field.String
	CustomerID      field.Int64
	OrderAmount     field.Float64
	OrderStatus     field.String
	OrderDate       field.Time
	PaymentMethod   field.String
	ShippingAddress field.String
	PushStatus      field.String // pending, pushed, failed
	CreatedAt       field.Time
	UpdatedAt       field.Time

	fieldMap map[string]field.Expr
}

func (d dwsOrder) Table(newTableName string) *dwsOrder {
	d.dwsOrderDo.UseTable(newTableName)
	return d.updateTableName(newTableName)
}

func (d dwsOrder) As(alias string) *dwsOrder {
	d.dwsOrderDo.DO = *(d.dwsOrderDo.As(alias).(*gen.DO))
	return d.updateTableName(alias)
}

func (d *dwsOrder) updateTableName(table string) *dwsOrder {
	d.ALL = field.NewAsterisk(table)
	d.ID = field.NewInt64(table, "id")
	d.OrderID = field.NewString(table, "order_id")
	d.CustomerID = field.NewInt64(table, "customer_id")
	d.OrderAmount = field.NewFloat64(table, "order_amount")
	d.OrderStatus = field.NewString(table, "order_status")
	d.OrderDate = field.NewTime(table, "order_date")
	d.PaymentMethod = field.NewString(table, "payment_method")
	d.ShippingAddress = field.NewString(table, "shipping_address")
	d.PushStatus = field.NewString(table, "push_status")
	d.CreatedAt = field.NewTime(table, "created_at")
	d.UpdatedAt = field.NewTime(table, "updated_at")

	d.fillFieldMap()

	return d
}

func (d *dwsOrder) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := d.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (d *dwsOrder) fillFieldMap() {
	d.fieldMap = make(map[string]field.Expr, 11)
	d.fieldMap["id"] = d.ID
	d.fieldMap["order_id"] = d.OrderID
	d.fieldMap["customer_id"] = d.CustomerID
	d.fieldMap["order_amount"] = d.OrderAmount
	d.fieldMap["order_status"] = d.OrderStatus
	d.fieldMap["order_date"] = d.OrderDate
	d.fieldMap["payment_method"] = d.PaymentMethod
	d.fieldMap["shipping_address"] = d.ShippingAddress
	d.fieldMap["push_status"] = d.PushStatus
	d.fieldMap["created_at"] = d.CreatedAt
	d.fieldMap["updated_at"] = d.UpdatedAt
}

func (d dwsOrder) clone(db *gorm.DB) dwsOrder {
	d.dwsOrderDo.ReplaceConnPool(db.Statement.ConnPool)
	return d
}

func (d dwsOrder) replaceDB(db *gorm.DB) dwsOrder {
	d.dwsOrderDo.ReplaceDB(db)
	return d
}

type dwsOrderDo struct{ gen.DO }

type IDwsOrderDo interface {
	gen.SubQuery
	Debug() IDwsOrderDo
	WithContext(ctx context.Context) IDwsOrderDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IDwsOrderDo
	WriteDB() IDwsOrderDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IDwsOrderDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IDwsOrderDo
	Not(conds ...gen.Condition) IDwsOrderDo
	Or(conds ...gen.Condition) IDwsOrderDo
	Select(conds ...field.Expr) IDwsOrderDo
	Where(conds ...gen.Condition) IDwsOrderDo
	Order(conds ...field.Expr) IDwsOrderDo
	Distinct(cols ...field.Expr) IDwsOrderDo
	Omit(cols ...field.Expr) IDwsOrderDo
	Join(table schema.Tabler, on ...field.Expr) IDwsOrderDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IDwsOrderDo
	RightJoin(table schema.Tabler, on ...field.Expr) IDwsOrderDo
	Group(cols ...field.Expr) IDwsOrderDo
	Having(conds ...gen.Condition) IDwsOrderDo
	Limit(limit int) IDwsOrderDo
	Offset(offset int) IDwsOrderDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IDwsOrderDo
	Unscoped() IDwsOrderDo
	Create(values ...*model.DwsOrder) error
	CreateInBatches(values []*model.DwsOrder, batchSize int) error
	Save(values ...*model.DwsOrder) error
	First() (*model.DwsOrder, error)
	Take() (*model.DwsOrder, error)
	Last() (*model.DwsOrder, error)
	Find() ([]*model.DwsOrder, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.DwsOrder, err error)
	FindInBatches(result *[]*model.DwsOrder, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.DwsOrder) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IDwsOrderDo
	Assign(attrs ...field.AssignExpr) IDwsOrderDo
	Joins(fields ...field.RelationField) IDwsOrderDo
	Preload(fields ...field.RelationField) IDwsOrderDo
	FirstOrInit() (*model.DwsOrder, error)
	FirstOrCreate() (*model.DwsOrder, error)
	FindByPage(offset int, limit int) (result []*model.DwsOrder, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IDwsOrderDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (d dwsOrderDo) Debug() IDwsOrderDo {
	return d.withDO(d.DO.Debug())
}

func (d dwsOrderDo) WithContext(ctx context.Context) IDwsOrderDo {
	return d.withDO(d.DO.WithContext(ctx))
}

func (d dwsOrderDo) ReadDB() IDwsOrderDo {
	return d.Clauses(dbresolver.Read)
}

func (d dwsOrderDo) WriteDB() IDwsOrderDo {
	return d.Clauses(dbresolver.Write)
}

func (d dwsOrderDo) Session(config *gorm.Session) IDwsOrderDo {
	return d.withDO(d.DO.Session(config))
}

func (d dwsOrderDo) Clauses(conds ...clause.Expression) IDwsOrderDo {
	return d.withDO(d.DO.Clauses(conds...))
}

func (d dwsOrderDo) Returning(value interface{}, columns ...string) IDwsOrderDo {
	return d.withDO(d.DO.Returning(value, columns...))
}

func (d dwsOrderDo) Not(conds ...gen.Condition) IDwsOrderDo {
	return d.withDO(d.DO.Not(conds...))
}

func (d dwsOrderDo) Or(conds ...gen.Condition) IDwsOrderDo {
	return d.withDO(d.DO.Or(conds...))
}

func (d dwsOrderDo) Select(conds ...field.Expr) IDwsOrderDo {
	return d.withDO(d.DO.Select(conds...))
}

func (d dwsOrderDo) Where(conds ...gen.Condition) IDwsOrderDo {
	return d.withDO(d.DO.Where(conds...))
}

func (d dwsOrderDo) Order(conds ...field.Expr) IDwsOrderDo {
	return d.withDO(d.DO.Order(conds...))
}

func (d dwsOrderDo) Distinct(cols ...field.Expr) IDwsOrderDo {
	return d.withDO(d.DO.Distinct(cols...))
}

func (d dwsOrderDo) Omit(cols ...field.Expr) IDwsOrderDo {
	return d.withDO(d.DO.Omit(cols...))
}

func (d dwsOrderDo) Join(table schema.Tabler, on ...field.Expr) IDwsOrderDo {
	return d.withDO(d.DO.Join(table, on...))
}

func (d dwsOrderDo) LeftJoin(table schema.Tabler, on ...field.Expr) IDwsOrderDo {
	return d.withDO(d.DO.LeftJoin(table, on...))
}

func (d dwsOrderDo) RightJoin(table schema.Tabler, on ...field.Expr) IDwsOrderDo {
	return d.withDO(d.DO.RightJoin(table, on...))
}

func (d dwsOrderDo) Group(cols ...field.Expr) IDwsOrderDo {
	return d.withDO(d.DO.Group(cols...))
}

func (d dwsOrderDo) Having(conds ...gen.Condition) IDwsOrderDo {
	return d.withDO(d.DO.Having(conds...))
}

func (d dwsOrderDo) Limit(limit int) IDwsOrderDo {
	return d.withDO(d.DO.Limit(limit))
}

func (d dwsOrderDo) Offset(offset int) IDwsOrderDo {
	return d.withDO(d.DO.Offset(offset))
}

func (d dwsOrderDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IDwsOrderDo {
	return d.withDO(d.DO.Scopes(funcs...))
}

func (d dwsOrderDo) Unscoped() IDwsOrderDo {
	return d.withDO(d.DO.Unscoped())
}

func (d dwsOrderDo) Create(values ...*model.DwsOrder) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Create(values)
}

func (d dwsOrderDo) CreateInBatches(values []*model.DwsOrder, batchSize int) error {
	return d.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (d dwsOrderDo) Save(values ...*model.DwsOrder) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Save(values)
}

func (d dwsOrderDo) First() (*model.DwsOrder, error) {
	if result, err := d.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.DwsOrder), nil
	}
}

func (d dwsOrderDo) Take() (*model.DwsOrder, error) {
	if result, err := d.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.DwsOrder), nil
	}
}

func (d dwsOrderDo) Last() (*model.DwsOrder, error) {
	if result, err := d.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.DwsOrder), nil
	}
}

func (d dwsOrderDo) Find() ([]*model.DwsOrder, error) {
	result, err := d.DO.Find()
	return result.([]*model.DwsOrder), err
}

func (d dwsOrderDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.DwsOrder, err error) {
	buf := make([]*model.DwsOrder, 0, batchSize)
	err = d.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (d dwsOrderDo) FindInBatches(result *[]*model.DwsOrder, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return d.DO.FindInBatches(result, batchSize, fc)
}

func (d dwsOrderDo) Attrs(attrs ...field.AssignExpr) IDwsOrderDo {
	return d.withDO(d.DO.Attrs(attrs...))
}

func (d dwsOrderDo) Assign(attrs ...field.AssignExpr) IDwsOrderDo {
	return d.withDO(d.DO.Assign(attrs...))
}

func (d dwsOrderDo) Joins(fields ...field.RelationField) IDwsOrderDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Joins(_f))
	}
	return &d
}

func (d dwsOrderDo) Preload(fields ...field.RelationField) IDwsOrderDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Preload(_f))
	}
	return &d
}

func (d dwsOrderDo) FirstOrInit() (*model.DwsOrder, error) {
	if result, err := d.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.DwsOrder), nil
	}
}

func (d dwsOrderDo) FirstOrCreate() (*model.DwsOrder, error) {
	if result, err := d.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.DwsOrder), nil
	}
}

func (d dwsOrderDo) FindByPage(offset int, limit int) (result []*model.DwsOrder, count int64, err error) {
	result, err = d.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = d.Offset(-1).Limit(-1).Count()
	return
}

func (d dwsOrderDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = d.Count()
	if err != nil {
		return
	}

	err = d.Offset(offset).Limit(limit).Scan(result)
	return
}

func (d dwsOrderDo) Scan(result interface{}) (err error) {
	return d.DO.Scan(result)
}

func (d dwsOrderDo) Delete(models ...*model.DwsOrder) (result gen.ResultInfo, err error) {
	return d.DO.Delete(models)
}

func (d *dwsOrderDo) withDO(do gen.Dao) *dwsOrderDo {
	d.DO = *do.(*gen.DO)
	return d
}
